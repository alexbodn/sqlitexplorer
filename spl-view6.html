<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<script>
			function cssLoad(src) {
				if (!src) {
					return Promise.resolve();
				}
				return new Promise((resolve, reject) => {
					let s = document.createElement('link');
					s.rel = 'stylesheet';
					s.href = src;
					s.onload = resolve;
					s.onerror = reject;
					document.head.append(s);
				});
			}
		</script>
		<script>
			async function jsLoad(src, module=false) {
				if (!src) {
					return Promise.resolve();
				}
				return new Promise((resolve, reject) => {
					let s = document.createElement('script');
					s.src = src;
					if (module) {
						s.type='module';
					}
					s.onload = resolve;
					s.onerror = reject;
					document.head.append(s);
				});
			}
		</script>
		<script>
			function prependScript(url) {
				return new Promise((resolve, reject) => {
					let s = document.createElement('script');
					s.src = url;
					s.onload = resolve;
					s.onerror = reject;
					document.currentScript.parentNode.insertBefore(
						s,
						document.currentScript,
					);
				});
			}
		</script>
		<script>
			async function demosql(dbUrl) {
				const demo1 = function(sqlite3, dbUrl, immutable=false) {
					fetch(dbUrl)
					.then(res => res.arrayBuffer())
					.then(arrayBuffer => {
						if (!immutable) {
							arrayBuffer.resizeable = true;
						}
						const p = sqlite3.wasm.allocFromTypedArray(arrayBuffer);
						const db = new sqlite3.oo1.DB();
						let deserialize_flags =
							sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE;
						if (!immutable) {
							deserialize_flags |= sqlite3.capi.SQLITE_DESERIALIZE_RESIZEABLE;
						}
						const rc = sqlite3.capi.sqlite3_deserialize(
							db.pointer, 'main', p, arrayBuffer.byteLength, arrayBuffer.byteLength, deserialize_flags);
						db.checkRc(rc);
						window.xplorer.setDb(db);
					});
				};
				const log = (...args)=>xplorer.log(...args);
				const warn = (...args)=>xplorer.warn(...args);
				const error = (...args)=>xplorer.error(...args);
				
				sqlite3InitModule({
					/* We can redirect any stdout/stderr from the module like so, but
						 note that doing so makes use of Emscripten-isms, not
						 well-defined sqlite APIs. */
					print: log,
					printErr: error
				}).then(function(sqlite3){
					//console.log('sqlite3 =',sqlite3);
					log("Done initializing. Running demo...");
					try {
						demo1(sqlite3, dbUrl);
					}catch(e){
						error("Exception:",e.message);
					}
				});
			}
			async function demospl(dbUrl) {
				const autoGeoJSON = {
					precision: 15,
					options: 2,
				};
				
				spl = await window.SPL(
					{
						autoGeoJSON,
					},
					[],
				);
				
				let autogpkg = 1;
				let withgpkg = true;
				
				const projdbUrl = new URL(
					'./node_modules/spl.js/dist/proj/proj.db', window.location.href).toString();
				let projData = await fetch(projdbUrl)
					.then(resp => resp.arrayBuffer());
				
				spl.mount('/proj', [{name: 'proj.db', data: projData}]);
				
				fetch(dbUrl)
					.then(resp => resp.arrayBuffer())
					.then(dbData => spl.db(dbData))
					.then(db => {
						db.read(`
							--nga gpkg have these hacks
							drop view if exists spatial_ref_sys;
							drop view if exists st_spatial_ref_sys;
							drop view if exists geometry_columns;
							drop view if exists st_geometry_columns;
						`)
						.read(init_spl({withgpkg, autogpkg}))
						.then((splDb) => {
							window.xplorer.setDb(splDb);
						})
					})
					;
			}
			
			function init_spl({projFile='/proj/proj.db', withgpkg=1, autogpkg=1}={}) {
				let pragmas = `
					PRAGMA foreign_keys = 1;
					PRAGMA recursive_triggers = 1;`;
				let init = `
					SELECT initspatialmetadatafull(1)
					where not exists (
						SELECT 1
						FROM sqlite_schema
						WHERE name LIKE 'geometry_columns'
					)
					;
					SELECT PROJ_SetDatabasePath('${projFile}'); -- set proj.db path
					`;
				let gpkg = `
					/**/
					SELECT EnableGpkgAmphibiousMode()
					WHERE getgpkgmode()=0;
					SELECT enablegpkgmode()
					WHERE GetGpkgAmphibiousMode()=0;
					/**/
					SELECT
						AutoGPKGStart(),
						--AutoGPKGStop(),
						''
					WHERE EXISTS (
						SELECT 1
						FROM sqlite_schema
						WHERE name LIKE 'gpkg_contents'
					)
					and ${autogpkg}=1
					`;
				if (!withgpkg) {
					gpkg = '';
				}
				return pragmas + init + gpkg;
			}
		</script>
		
		<style>
			body {
				/*margin: 0px;*/
				margin-left: 0;
				margin-right: 0;
			}
			div#sqlDiv, #map {
				width: 98vw;
				height: 59vh;
				margin-top: 1vh;
				margin-right: 1vw;
				margin-left: 1vw;
				border: solid 1px gray;
				
				/*position: fixed;*/
			}
		</style>
		<title>
			spl-view
		</title>
	</head>
	<body>
		<script>
let dbUrl = new URL(
	'./tests/files/dbs/DCTour.gpkg', window.location.href).toString();

Promise.all([
	jsLoad('./lib/map_show.js'),
])
.then(() => {
	return Promise.all([
		jsLoad("./lib/map_show_leaflet.js"),
		jsLoad("./lib/map_show_ol.js"),
	]);
})
.then(() => {
	window.DisplayClass =
	DisplayLeaflet
	//DisplayOpenLayers
	;
	return Promise.all([
		jsLoad("./lib/sqlitexplorer.js"),
		jsLoad("./lib/loadspl.js", true),
		jsLoad("./node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3.js"),
		window.DisplayClass.resources()
	]);
})
.then(() => {
	let html = `<div id="sqlDiv"></div>`;
	document.body.insertAdjacentHTML('beforeend', html);
	let div = document.querySelector('div#sqlDiv');
	window.xplorer = new SQLiteXplorer(div, {
		build_map: window.DisplayClass,
		withProj4JS: true,
	});
	const map = window.xplorer.getMap();
	map._addLayer(
		map.
		bw_layer()
		//osm_layer()
	);
	window.log = window.xplorer.log;
})
.then(() => {
	demosql(dbUrl);
});
		</script>
		<!--script src="./lib/eruda.js" type="text/javascript"></script-->
	</body>
</html>
